(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define(["React"], factory);
	else if(typeof exports === 'object')
		exports["ReactScrollView"] = factory(require("React"));
	else
		root["ReactScrollView"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) { var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(19)();
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isIOS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return forwardRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return eventOptions; });
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var iOSUserAgentRegExp = /(iphone|ipod|ipad)/i;
var isIOS = iOSUserAgentRegExp.test(navigator.userAgent);

var createId = function createId() {
	return (createId.id = (createId.id || 0) + 1).toString();
};

var noop = function noop() {};

function debounce(func, wait) {
	var timeoutId = void 0;
	var timestamp = void 0;
	var args = void 0;
	var result = void 0;

	var later = function later() {
		var last = Date.now() - timestamp;
		if (last < wait && last >= 0) {
			timeoutId = setTimeout(later, wait - last);
		} else {
			timeoutId = null;
			result = func.apply(undefined, _toConsumableArray(args));
			args = null;
		}
	};

	var debounced = function debounced() {
		for (var _len = arguments.length, latestArgs = Array(_len), _key = 0; _key < _len; _key++) {
			latestArgs[_key] = arguments[_key];
		}

		args = latestArgs;
		timestamp = Date.now();
		if (!timeoutId) {
			timeoutId = setTimeout(later, wait);
		}
		return result;
	};

	debounced.clearDebounce = function () {
		timeoutId && clearTimeout(timeoutId);
	};

	return debounced;
}

function forwardRef(ref, dom) {
	if (ref) {
		typeof ref === 'function' ? ref(dom) : ref.current = dom;
	}
}

var eventOptions = function getEventOptions() {
	var passiveOptionSupported = false;
	var opts = Object.defineProperty({}, 'passive', {
		get: function get() {
			return passiveOptionSupported = true;
		}
	});
	try {
		window.addEventListener('test', null, opts);
	} catch (e) {}

	if (passiveOptionSupported) {
		return {
			passive: false,
			capture: false
		};
	}
	return false;
}();

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ObserverContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return StickyContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FixedContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return RefreshContext; });
/* harmony import */ var create_react_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var create_react_context__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(create_react_context__WEBPACK_IMPORTED_MODULE_0__);


var ObserverContext = create_react_context__WEBPACK_IMPORTED_MODULE_0___default()({
	ref: function ref() {},
	isIntersecting: true
});

var StickyContext = create_react_context__WEBPACK_IMPORTED_MODULE_0___default()();

var FixedContext = create_react_context__WEBPACK_IMPORTED_MODULE_0___default()();

var RefreshContext = create_react_context__WEBPACK_IMPORTED_MODULE_0___default()();

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return refType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return thresholdType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return stickyNodeType; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);


var refType = Object(prop_types__WEBPACK_IMPORTED_MODULE_0__["oneOfType"])([prop_types__WEBPACK_IMPORTED_MODULE_0__["func"], prop_types__WEBPACK_IMPORTED_MODULE_0__["object"]]);
var thresholdType = Object(prop_types__WEBPACK_IMPORTED_MODULE_0__["oneOfType"])([prop_types__WEBPACK_IMPORTED_MODULE_0__["number"], Object(prop_types__WEBPACK_IMPORTED_MODULE_0__["arrayOf"])(prop_types__WEBPACK_IMPORTED_MODULE_0__["number"])]);
var stickyNodeType = Object(prop_types__WEBPACK_IMPORTED_MODULE_0__["oneOfType"])([prop_types__WEBPACK_IMPORTED_MODULE_0__["func"], prop_types__WEBPACK_IMPORTED_MODULE_0__["node"]]);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @providesModule warning
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = "production" !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _implementation = __webpack_require__(14);

var _implementation2 = _interopRequireDefault(_implementation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _react2.default.createContext || _implementation2.default;
module.exports = exports['default'];

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Contexts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _Intersection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var _PropTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var ScrollObserver = function (_Component) {
	_inherits(ScrollObserver, _Component);

	function ScrollObserver() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ScrollObserver);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ScrollObserver.__proto__ || Object.getPrototypeOf(ScrollObserver)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ScrollObserver, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			var onEnter = this.onEnter,
			    onLeave = this.onLeave,
			    dom = this.dom,
			    _props = this.props,
			    rootMargin = _props.rootMargin,
			    threshold = _props.threshold,
			    onIntersect = _props.onIntersect,
			    debugId = _props.debugId;

			process.nextTick(function () {
				var intersection = new _Intersection__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({
					onEnter: onEnter,
					onLeave: onLeave,
					onIntersect: onIntersect,
					debugId: debugId
				});
				if (dom) {
					var options = { rootMargin: rootMargin, threshold: threshold };
					_this2.observer.observe(dom, intersection, options);
				}
			});
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var dom = this.dom;

			if (dom) this.observer.unobserve(dom);
		}
	}, {
		key: 'render',
		value: function render() {
			return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
				_Contexts__WEBPACK_IMPORTED_MODULE_2__[/* ObserverContext */ "b"].Consumer,
				null,
				this.renderChildren
			);
		}
	}]);

	return ScrollObserver;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

ScrollObserver.propTypes = {
	children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
	onEnter: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
	onLeave: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
	onIntersect: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
	rootMargin: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
	threshold: _PropTypes__WEBPACK_IMPORTED_MODULE_5__[/* thresholdType */ "c"],
	innerRef: _PropTypes__WEBPACK_IMPORTED_MODULE_5__[/* refType */ "a"],
	debugId: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string
};

var _initialiseProps = function _initialiseProps() {
	var _this3 = this;

	this.state = {
		isIntersecting: false,
		ref: function ref(dom) {
			Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* forwardRef */ "d"])(_this3.props.innerRef, dom);
			_this3.dom = dom;
		}
	};

	this.onEnter = function () {
		var isIntersecting = _this3.state.isIntersecting,
		    onEnter = _this3.props.onEnter;

		!isIntersecting && _this3.setState({ isIntersecting: true });
		onEnter && onEnter.apply(undefined, arguments);
	};

	this.onLeave = function () {
		var isIntersecting = _this3.state.isIntersecting,
		    onLeave = _this3.props.onLeave;

		isIntersecting && _this3.setState({ isIntersecting: false });
		onLeave && onLeave.apply(undefined, arguments);
	};

	this.renderChildren = function (observer) {
		var state = _this3.state,
		    children = _this3.props.children;

		_this3.observer = observer;
		return children(state);
	};
};

/* harmony default export */ __webpack_exports__["a"] = (ScrollObserver);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./src/util.js
var util = __webpack_require__(2);

// CONCATENATED MODULE: ./src/EntryState.js
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EntryState = function () {
	function EntryState(entry, debugId) {
		_classCallCheck(this, EntryState);

		this.entry = entry;
		this.debugId = debugId;
	}

	_createClass(EntryState, [{
		key: "isOffsetTop",
		get: function get() {
			var entry = this.entry;

			return !entry.isIntersecting && entry.boundingClientRect.bottom < entry.rootBounds.bottom;
		}
	}, {
		key: "isOffsetBottom",
		get: function get() {
			var entry = this.entry;

			return !entry.isIntersecting && entry.boundingClientRect.bottom > entry.rootBounds.bottom;
		}
	}, {
		key: "isTopVisible",
		get: function get() {
			var entry = this.entry;

			return entry.isIntersecting && entry.boundingClientRect.top >= entry.rootBounds.top;
		}
	}, {
		key: "isBottomVisible",
		get: function get() {
			var entry = this.entry;

			return entry.isIntersecting && entry.boundingClientRect.bottom <= entry.rootBounds.bottom;
		}
	}, {
		key: "isTopBoundary",
		get: function get() {
			var entry = this.entry;

			return entry.isIntersecting && entry.boundingClientRect.top === entry.rootBounds.top;
		}
	}, {
		key: "isBottomBoundary",
		get: function get() {
			var entry = this.entry;

			return entry.isIntersecting && entry.boundingClientRect.bottom === entry.rootBounds.bottom;
		}
	}]);

	return EntryState;
}();

/* harmony default export */ var src_EntryState = (EntryState);
// CONCATENATED MODULE: ./src/Intersection.js
var Intersection_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Intersection_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




var Intersection_Intersection = function () {
	function Intersection(_ref) {
		var onEnter = _ref.onEnter,
		    onLeave = _ref.onLeave,
		    onIntersect = _ref.onIntersect,
		    _ref$debugId = _ref.debugId,
		    debugId = _ref$debugId === undefined ? '' : _ref$debugId;

		Intersection_classCallCheck(this, Intersection);

		this._onIntersect = onIntersect || util["f" /* noop */];
		this.onEnter = onEnter || util["f" /* noop */];
		this.onLeave = onLeave || util["f" /* noop */];
		this._isIntersecting = false;
		this.debugId = debugId; // useful for debug
	}

	Intersection_createClass(Intersection, [{
		key: 'onIntersect',
		value: function onIntersect(eventData) {
			var entry = eventData.entry;
			var isIntersecting = entry.isIntersecting;

			var entryState = new src_EntryState(entry, this.debugId);
			if (this._isIntersecting !== isIntersecting) {
				this._isIntersecting = isIntersecting;
				this[isIntersecting ? 'onEnter' : 'onLeave'](entryState);
			}
			this._onIntersect(entryState);
		}
	}]);

	return Intersection;
}();

/* harmony default export */ var src_Intersection = __webpack_exports__["a"] = (Intersection_Intersection);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/util.js
var util = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/memoize-one/dist/memoize-one.esm.js
var simpleIsEqual = function simpleIsEqual(a, b) {
  return a === b;
};

function memoize_one_esm_index (resultFn, isEqual) {
  if (isEqual === void 0) {
    isEqual = simpleIsEqual;
  }

  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;

  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
    return isEqual(newArg, lastArgs[index]);
  };

  var result = function result() {
    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }

    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
      return lastResult;
    }

    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  };

  return result;
}

/* harmony default export */ var memoize_one_esm = (memoize_one_esm_index);

// CONCATENATED MODULE: ./src/Style.js


function create(styles) {
	return function createStyle() {
		return Object.keys(styles).reduce(function (finalStyles, key) {
			var val = styles[key];
			finalStyles[key] = typeof val === 'function' ? memoize_one_esm(val) : val;
			return finalStyles;
		}, {});
	};
}
// CONCATENATED MODULE: ./src/components/ScrollView.styles.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/* harmony default export */ var ScrollView_styles = (create({
	container: function container(style) {
		return _extends({
			position: 'relative'
		}, style);
	},
	main: function main(direction, disabled) {
		var _res;

		var overflowHidden = direction === 'vertical' ? 'overflowX' : 'overflowY';
		var overflowScroll = direction === 'vertical' ? 'overflowY' : 'overflowX';
		var res = (_res = {
			// all: 'inherit',
			position: 'relative',
			height: '100%',
			width: '100%'
		}, _defineProperty(_res, overflowHidden, 'hidden'), _defineProperty(_res, overflowScroll, disabled ? 'hidden' : util["e" /* isIOS */] ? 'scroll' : 'auto'), _res);
		if (util["e" /* isIOS */]) res.WebkitOverflowScrolling = 'touch';
		return res;
	},
	background: function background(direction) {
		var vertical = {
			width: '100%',
			height: 'calc(100% + 1px)'
		};
		var horizontal = {
			width: 'calc(100% + 1px)',
			height: '100%'
		};
		var style = direction === 'vertical' ? vertical : horizontal;
		return _extends({
			position: 'absolute',
			top: 0,
			left: 0,
			zIndex: -1
		}, style);
	},
	endHook: function endHook(bottom) {
		return {
			position: 'relative',
			bottom: bottom
		};
	},
	fixedContainer: function fixedContainer(style) {
		return _extends({}, style, {
			position: 'absolute',
			left: 0,
			right: 0,
			top: 0,
			height: 0,
			zIndex: 666666
		});
	}
}));
// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(0);
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(1);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./src/PropTypes.js
var PropTypes = __webpack_require__(4);

// CONCATENATED MODULE: ./src/MapPolyfill.js
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var MapPolyfill_MapPolyfill = function () {
	function MapPolyfill() {
		_classCallCheck(this, MapPolyfill);

		this._store = [];
		this._key = '__map' + Object(util["a" /* createId */])();
	}

	_createClass(MapPolyfill, [{
		key: 'has',
		value: function has(obj) {
			return !!~this._store.indexOf(obj);
		}
	}, {
		key: 'set',
		value: function set(obj, val) {
			if (!this.has(obj)) {
				obj[this._key] = val;
				this._store.push(obj);
			}
		}
	}, {
		key: 'get',
		value: function get(obj) {
			if (this.has(obj)) return obj[this._key];
		}
	}, {
		key: 'delete',
		value: function _delete(obj) {
			var index = this._store.indexOf(obj);
			if (index > -1) {
				delete obj[this._key];
				this._store.splice(index, 1);
			}
		}
	}, {
		key: 'size',
		get: function get() {
			return this._store.length;
		}
	}]);

	return MapPolyfill;
}();

/* harmony default export */ var src_MapPolyfill = (Map || MapPolyfill_MapPolyfill);
// EXTERNAL MODULE: ./node_modules/warning/warning.js
var warning = __webpack_require__(5);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning);

// EXTERNAL MODULE: ./src/Intersection.js + 1 modules
var Intersection = __webpack_require__(8);

// CONCATENATED MODULE: ./src/Observer.js
var Observer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Observer_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Observer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }





if (!IntersectionObserver) {
	throw new Error(['react-scroll-view requires `IntersectionObserver`.', 'You may add this polyfill to fix the issue.', '`https://github.com/w3c/IntersectionObserver/tree/master/polyfill`'].join(' '));
}

var createBox = function createBox(observer, intersection) {
	return {
		observer: observer,
		intersection: intersection
	};
};

var Observer_Observer = function () {
	function Observer() {
		Observer_classCallCheck(this, Observer);

		this._boxes = new src_MapPolyfill();
		this._prevScrollPos = 0;
		this._currScrollPos = 0;
	}

	Observer_createClass(Observer, [{
		key: 'mount',
		value: function mount(root) {
			this.root = root;
		}
	}, {
		key: 'observe',
		value: function observe(target, intersection, options) {
			var _this = this;

			if (!this.root) {
				return warning_default()(false, 'Should call observer.mount(root) before calling observer.observe()');
			}

			if (intersection instanceof Intersection["a" /* default */] && !this._boxes.has(target)) {
				var callback = function callback(entries) {
					return entries.forEach(function (entry) {
						var target = entry.target;

						if (_this._boxes.has(target)) {
							var _boxes$get = _this._boxes.get(target),
							    _intersection = _boxes$get.intersection;

							_intersection.onIntersect({ entry: entry });
						}
					});
				};
				var observer = new IntersectionObserver(callback, Observer_extends({
					root: this.root
				}, options));
				var box = createBox(observer, intersection);
				this._boxes.set(target, box);
				observer.observe(target);
			}
		}
	}, {
		key: 'unobserve',
		value: function unobserve(target) {
			var box = this._boxes.get(target);
			if (box) {
				var observer = box.observer;

				observer.unobserve(target);
				observer.disconnect();
				this._boxes.delete(target);
			}
		}
	}]);

	return Observer;
}();

/* harmony default export */ var src_Observer = (Observer_Observer);
// CONCATENATED MODULE: ./src/FixedState.js
var FixedState_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function FixedState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FixedState = function () {
	function FixedState() {
		FixedState_classCallCheck(this, FixedState);

		this.children = [];
	}

	FixedState_createClass(FixedState, [{
		key: "bind",
		value: function bind(reactInstance) {
			if (!this.forceUpdate) {
				this.forceUpdate = reactInstance.forceUpdate.bind(reactInstance);
			}
		}
	}, {
		key: "unbind",
		value: function unbind() {
			this.forceUpdate = null;
		}
	}, {
		key: "_findIndexByKey",
		value: function _findIndexByKey(key) {
			var children = this.children;
			var length = children.length;

			var index = -1;
			for (var i = 0; i < length; i++) {
				var curr = children[i];
				if (curr && curr.key === key) {
					index = i;
					break;
				}
			}
			return index;
		}
	}, {
		key: "unmount",
		value: function unmount(key) {
			var index = this._findIndexByKey(key);
			if (index > -1) {
				this.children.splice(index, 1);
				this.forceUpdate && this.forceUpdate();
			}
		}
	}, {
		key: "render",
		value: function render(child) {
			var children = this.children;
			var key = child.key;

			var index = this._findIndexByKey(key);
			if (index > -1) children.splice(index, 1, child);else children.push(child);
			this.forceUpdate && this.forceUpdate();
		}
	}]);

	return FixedState;
}();

/* harmony default export */ var src_FixedState = (FixedState);
// CONCATENATED MODULE: ./src/RefreshState.js
var RefreshState_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function RefreshState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RefreshState = function () {
	function RefreshState() {
		RefreshState_classCallCheck(this, RefreshState);
	}

	RefreshState_createClass(RefreshState, [{
		key: "mount",
		value: function mount(reactInstance) {
			this.reactInstance = reactInstance;
		}
	}, {
		key: "unmount",
		value: function unmount() {
			this.reactInstance = null;
		}
	}, {
		key: "call",
		value: function call(method) {
			if (this.reactInstance) {
				var _reactInstance;

				for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					args[_key - 1] = arguments[_key];
				}

				(_reactInstance = this.reactInstance)[method].apply(_reactInstance, args);
			}
		}
	}]);

	return RefreshState;
}();

/* harmony default export */ var src_RefreshState = (RefreshState);
// CONCATENATED MODULE: ./src/PullingDown.js
var PullingDown_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function PullingDown_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var PullingDown_PullingDown = function () {
	function PullingDown(dom) {
		PullingDown_classCallCheck(this, PullingDown);

		this._preventWindowScroll = function (ev) {
			ev.cancelable !== false && ev.preventDefault();
		};

		this._dom = dom;
		this.isActive = false;
	}

	PullingDown_createClass(PullingDown, [{
		key: 'start',
		value: function start() {
			window.addEventListener('touchmove', this._preventWindowScroll, util["c" /* eventOptions */]);

			this.isActive = true;
			this._overflowStyle = this._dom.style.overflowY;
			this._dom.style.overflowY = 'hidden';
		}
	}, {
		key: 'stop',
		value: function stop() {
			window.removeEventListener('touchmove', this._preventWindowScroll, util["c" /* eventOptions */]);

			this.isActive = false;
			this._dom.style.overflowY = this._overflowStyle;
		}
	}]);

	return PullingDown;
}();

/* harmony default export */ var src_PullingDown = (PullingDown_PullingDown);
// CONCATENATED MODULE: ./src/components/Hook.styles.js
var Hook_styles_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/* harmony default export */ var Hook_styles = (create({
	hook: function hook(style) {
		return Hook_styles_extends({
			pointerEvents: 'none'
		}, style);
	}
}));
// EXTERNAL MODULE: ./src/components/ScrollObserver.js
var ScrollObserver = __webpack_require__(7);

// CONCATENATED MODULE: ./src/components/Hook.js
var Hook_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Hook_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Hook_Hook = function (_Component) {
	_inherits(Hook, _Component);

	function Hook() {
		var _ref;

		var _temp, _this, _ret;

		Hook_classCallCheck(this, Hook);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Hook.__proto__ || Object.getPrototypeOf(Hook)).call.apply(_ref, [this].concat(args))), _this), _this.styles = Hook_styles(), _temp), _possibleConstructorReturn(_this, _ret);
	}

	Hook_createClass(Hook, [{
		key: 'render',
		value: function render() {
			var _props = this.props,
			    style = _props.style,
			    other = _objectWithoutProperties(_props, ['style']),
			    styles = this.styles;

			return external_React_default.a.createElement(
				ScrollObserver["a" /* default */],
				other,
				function (_ref2) {
					var ref = _ref2.ref;
					return external_React_default.a.createElement('div', {
						role: 'none',
						'aria-label': 'react-scroll-hook',
						ref: ref,
						style: styles.hook(style)
					});
				}
			);
		}
	}]);

	return Hook;
}(external_React_["Component"]);

Hook_Hook.propTypes = {
	style: prop_types_default.a.object
};
/* harmony default export */ var components_Hook = (Hook_Hook);
// EXTERNAL MODULE: ./src/Contexts.js
var Contexts = __webpack_require__(3);

// CONCATENATED MODULE: ./src/components/FixedContainer.js
var FixedContainer_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function FixedContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FixedContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function FixedContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var FixedContainer_FixedContainer = function (_Component) {
	FixedContainer_inherits(FixedContainer, _Component);

	function FixedContainer() {
		var _ref;

		var _temp, _this, _ret;

		FixedContainer_classCallCheck(this, FixedContainer);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = FixedContainer_possibleConstructorReturn(this, (_ref = FixedContainer.__proto__ || Object.getPrototypeOf(FixedContainer)).call.apply(_ref, [this].concat(args))), _this), _this.renderChildren = function (fixedState) {
			_this.fixedState = fixedState;
			_this.unbind = fixedState.bind(_this);
			var children = fixedState.children;

			return children.length ? external_React_default.a.createElement(
				'div',
				_this.props,
				children
			) : null;
		}, _temp), FixedContainer_possibleConstructorReturn(_this, _ret);
	}

	FixedContainer_createClass(FixedContainer, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.fixedState.unbind();
		}
	}, {
		key: 'render',
		value: function render() {
			return external_React_default.a.createElement(
				Contexts["a" /* FixedContext */].Consumer,
				null,
				this.renderChildren
			);
		}
	}]);

	return FixedContainer;
}(external_React_["Component"]);

/* harmony default export */ var components_FixedContainer = (FixedContainer_FixedContainer);
// CONCATENATED MODULE: ./src/components/ScrollView.js
var ScrollView_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var ScrollView_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function ScrollView_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ScrollView_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ScrollView_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ScrollView_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }















var ScrollView_ScrollView = function (_Component) {
	ScrollView_inherits(ScrollView, _Component);

	function ScrollView(props) {
		ScrollView_classCallCheck(this, ScrollView);

		var _this = ScrollView_possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).call(this, props));

		ScrollView_initialiseProps.call(_this);

		var isHorizontal = props.isHorizontal,
		    onEndReached = props.onEndReached,
		    refreshControl = props.refreshControl;


		warning_default()(!isHorizontal || !refreshControl, '`refreshControl` with `isHorizontal` is NOT supported, `refreshControl` will be ignored');

		warning_default()(!isHorizontal || !onEndReached, '`onEndReached` with `isHorizontal` is NOT supported, `onEndReached` will be ignored');

		_this.styles = ScrollView_styles();
		_this.observer = new src_Observer();
		_this.toEmitOnScrollEnd = Object(util["b" /* debounce */])(function (ev) {
			var onScrollEnd = _this.props.onScrollEnd;

			_this.isScrolling = false;
			onScrollEnd && onScrollEnd(ev);
		}, 100);

		_this.fixedState = new src_FixedState();

		if (props.refreshControl) _this.refreshState = new src_RefreshState();
		return _this;
	}

	ScrollView_createClass(ScrollView, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var dom = this.dom;

			this.observer.mount(dom);
			this.registerTouchEvents(dom);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var dom = this.dom;

			this.toEmitOnScrollEnd.clearDebounce();
			this.unregisterTouchEvents(dom);
		}
	}, {
		key: 'scrollTo',
		value: function scrollTo() {
			var _dom;

			var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			var args = this.props.isHorizontal ? [val, 0] : [0, val];
			(_dom = this.dom).scrollTo.apply(_dom, args);
		}
	}, {
		key: 'render',
		value: function render() {
			var _props = this.props,
			    style = _props.style,
			    className = _props.className,
			    contentContainerStyle = _props.contentContainerStyle,
			    contentContainerClassName = _props.contentContainerClassName,
			    children = _props.children,
			    onScrollStart = _props.onScrollStart,
			    onScrollEnd = _props.onScrollEnd,
			    onEndReached = _props.onEndReached,
			    endReachedThreshold = _props.endReachedThreshold,
			    isHorizontal = _props.isHorizontal,
			    disabled = _props.disabled,
			    refreshControl = _props.refreshControl,
			    innerRef = _props.innerRef,
			    other = ScrollView_objectWithoutProperties(_props, ['style', 'className', 'contentContainerStyle', 'contentContainerClassName', 'children', 'onScrollStart', 'onScrollEnd', 'onEndReached', 'endReachedThreshold', 'isHorizontal', 'disabled', 'refreshControl', 'innerRef']),
			    styles = this.styles,
			    observer = this.observer,
			    fixedState = this.fixedState,
			    refreshState = this.refreshState;

			var direction = isHorizontal ? 'horizontal' : 'vertical';
			return external_React_default.a.createElement(
				Contexts["b" /* ObserverContext */].Provider,
				{ value: observer },
				external_React_default.a.createElement(
					Contexts["a" /* FixedContext */].Provider,
					{ value: fixedState },
					external_React_default.a.createElement(
						Contexts["c" /* RefreshContext */].Provider,
						{ value: refreshState },
						external_React_default.a.createElement(
							'div',
							{ style: styles.container(style), className: className },
							external_React_default.a.createElement(
								'div',
								ScrollView_extends({}, other, {
									style: styles.main(direction, disabled),
									ref: this.scrollViewRef,
									onScroll: this.handleScroll
								}),
								!isHorizontal && refreshControl,
								external_React_default.a.createElement(
									'div',
									{
										style: contentContainerStyle,
										className: contentContainerClassName
									},
									children
								),
								util["e" /* isIOS */] && external_React_default.a.createElement('div', { style: styles.background(direction) }),
								!isHorizontal && external_React_default.a.createElement(components_Hook, {
									style: styles.endHook(endReachedThreshold),
									onEnter: this.handleEndEnter
								})
							),
							external_React_default.a.createElement(
								components_FixedContainer,
								{
									style: styles.fixedContainer(contentContainerStyle)
								},
								fixedState.children
							)
						)
					)
				)
			);
		}
	}]);

	return ScrollView;
}(external_React_["Component"]);

ScrollView_ScrollView.propTypes = {
	style: prop_types_default.a.object,
	className: prop_types_default.a.string,
	contentContainerStyle: prop_types_default.a.object,
	contentContainerClassName: prop_types_default.a.string,
	children: prop_types_default.a.node,
	onScrollStart: prop_types_default.a.func,
	onScroll: prop_types_default.a.func,
	onScrollEnd: prop_types_default.a.func,
	onEndReached: prop_types_default.a.func,
	endReachedThreshold: prop_types_default.a.number,
	isHorizontal: prop_types_default.a.bool,
	innerRef: PropTypes["a" /* refType */],
	disabled: prop_types_default.a.bool,
	refreshControl: prop_types_default.a.node
};
ScrollView_ScrollView.defaultProps = {
	endReachedThreshold: 0,
	isHorizontal: false,
	disabled: false
};

var ScrollView_initialiseProps = function _initialiseProps() {
	var _this2 = this;

	this.scrollViewRef = function (dom) {
		Object(util["d" /* forwardRef */])(_this2.props.innerRef, dom);
		_this2.dom = dom;
	};

	this.registerTouchEvents = function (dom) {
		if (!_this2.refreshState) return;
		_this2.pullingDown = new src_PullingDown(_this2.dom);
		dom.addEventListener('touchstart', _this2.handleTouchStart, util["c" /* eventOptions */]);
	};

	this.unregisterTouchEvents = function (dom) {
		if (!_this2.refreshState) return;
		dom.removeEventListener('touchstart', _this2.handleTouchStart, util["c" /* eventOptions */]);
	};

	this.handleEndEnter = function () {
		var onEndReached = _this2.props.onEndReached;

		if (onEndReached) onEndReached();
	};

	this.handleScroll = function (ev) {
		var _props2 = _this2.props,
		    onScrollStart = _props2.onScrollStart,
		    onScroll = _props2.onScroll,
		    isScrolling = _this2.isScrolling;

		if (!isScrolling) {
			_this2.isScrolling = true;
			onScrollStart && onScrollStart(ev);
		}
		onScroll && onScroll(ev);
		_this2.toEmitOnScrollEnd(ev);
	};

	this.handleTouchStart = function (ev) {
		var dom = _this2.dom;

		_this2.y0 = ev.touches[0].clientY;
		dom.addEventListener('touchmove', _this2.handleTouchMove, util["c" /* eventOptions */]);
		dom.addEventListener('touchend', _this2.handleTouchEnd, util["c" /* eventOptions */]);
	};

	this.handleTouchMove = function (ev) {
		var touchClient = ev.touches[0];
		var dy = touchClient.clientY - _this2.y0;
		if (!_this2.pullingDown.isActive) {
			if (_this2.dom.scrollTop <= 0) {
				if (dy > 0) {
					_this2.pullingDown.start();
					_this2.refreshState.call('disableTransition');
				}
			} else {
				_this2.y0 = touchClient.clientY;
			}
		} else if (dy <= 0) {
			_this2.refreshState.call('setHeight', 0);
			_this2.pullingDown.stop();
		}

		if (_this2.pullingDown.isActive) {
			_this2.refreshState.call('setHeight', dy);
		}
	};

	this.handleTouchEnd = function () {
		var dom = _this2.dom;

		_this2.y0 = 0;
		if (_this2.pullingDown.isActive) {
			_this2.refreshState.call('attemptToRefresh');
			_this2.pullingDown.stop();
		}

		dom.removeEventListener('touchmove', _this2.handleTouchMove, util["c" /* eventOptions */]);
		dom.removeEventListener('touchend', _this2.handleTouchEnd, util["c" /* eventOptions */]);
	};
};

/* harmony default export */ var components_ScrollView = (ScrollView_ScrollView);
// CONCATENATED MODULE: ./src/components/StickySection.styles.js
var StickySection_styles_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/* harmony default export */ var StickySection_styles = (create({
	container: function container(style) {
		return StickySection_styles_extends({
			position: 'relative'
		}, style);
	},
	topHook: {
		position: 'absolute',
		top: 0
	},
	bottomHook: function bottomHook() {
		var bottom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
		return {
			position: 'absolute',
			bottom: bottom,
			top: 0,
			left: 0,
			right: 0,
			zIndex: -666

			// boxShadow: '0 0 0 2px red',
		};
	},
	sticky: function sticky(zIndex) {
		return { zIndex: zIndex };
	}
}));
// CONCATENATED MODULE: ./src/components/Sticky.styles.js
var Sticky_styles_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Sticky_styles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var Sticky_styles = (create({
	fixed: function fixed(style) {
		return Sticky_styles_extends({
			position: 'absolute',
			top: 0,
			// width: 'inherit',
			left: 'inherit',
			right: 'inherit',
			paddingLeft: 'inherit',
			paddingRight: 'inherit',
			marginLeft: 'inherit',
			marginRight: 'inherit'
		}, style);
	},
	relative: function relative(style, topOrBottom) {
		return Sticky_styles_extends(Sticky_styles_defineProperty({
			position: 'absolute',
			zIndex: 1,
			left: 0,
			right: 0
		}, topOrBottom, 0), style);
	}
}));
// CONCATENATED MODULE: ./src/components/Fixed.js
var Fixed_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Fixed_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Fixed_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Fixed_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Fixed_Fixed = function (_Component) {
	Fixed_inherits(Fixed, _Component);

	function Fixed(props) {
		Fixed_classCallCheck(this, Fixed);

		var _this = Fixed_possibleConstructorReturn(this, (Fixed.__proto__ || Object.getPrototypeOf(Fixed)).call(this, props));

		_this.renderChildren = function (fixedContext) {
			_this.fixedContext = fixedContext;
			return null;
		};

		_this.fixedId = Object(util["a" /* createId */])();
		return _this;
	}

	Fixed_createClass(Fixed, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.renderInContext();
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(_ref) {
			var children = _ref.children;

			if (children !== this.props.children) {
				this.renderInContext();
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.fixedContext.unmount(this.fixedId);
		}
	}, {
		key: 'renderInContext',
		value: function renderInContext() {
			var fixedContext = this.fixedContext,
			    fixedId = this.fixedId,
			    children = this.props.children;

			if (fixedContext.render) {
				fixedContext.render(Object(external_React_["cloneElement"])(external_React_["Children"].only(children), { key: fixedId }));
			}
		}
	}, {
		key: 'render',
		value: function render() {
			return external_React_default.a.createElement(
				Contexts["a" /* FixedContext */].Consumer,
				null,
				this.renderChildren
			);
		}
	}]);

	return Fixed;
}(external_React_["Component"]);

Fixed_Fixed.propTypes = {
	children: prop_types_default.a.node
};
/* harmony default export */ var components_Fixed = (Fixed_Fixed);
// CONCATENATED MODULE: ./src/components/Sticky.js
var Sticky_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Sticky_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Sticky_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Sticky_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var Sticky_Sticky = function (_Component) {
	Sticky_inherits(Sticky, _Component);

	function Sticky() {
		var _ref;

		var _temp, _this, _ret;

		Sticky_classCallCheck(this, Sticky);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = Sticky_possibleConstructorReturn(this, (_ref = Sticky.__proto__ || Object.getPrototypeOf(Sticky)).call.apply(_ref, [this].concat(args))), _this), _this.styles = Sticky_styles(), _this.saveDOMNode = function (dom) {
			if (dom && !_this.dom && _this.stickyContext) {
				var _dom$getBoundingClien = dom.getBoundingClientRect(),
				    height = _dom$getBoundingClien.height;

				_this.stickyContext.setStickyStyle({ height: height });
			}
			_this.dom = dom;
		}, _this.renderChildren = function (stickyContext) {
			_this.stickyContext = stickyContext;
			var _this2 = _this,
			    style = _this2.props.style,
			    position = _this2.stickyContext.position,
			    styles = _this2.styles;

			if (position === 'fixed') {
				return external_React_default.a.createElement(
					components_Fixed,
					null,
					external_React_default.a.createElement(
						'div',
						{ ref: _this.saveDOMNode, style: styles.fixed(style) },
						_this.returnChildren(position)
					)
				);
			} else {
				var topOrBottom = position;
				return external_React_default.a.createElement(
					'div',
					{ ref: _this.saveDOMNode, style: styles.relative(style, topOrBottom) },
					_this.returnChildren(position)
				);
			}
		}, _temp), Sticky_possibleConstructorReturn(_this, _ret);
	}

	Sticky_createClass(Sticky, [{
		key: 'returnChildren',
		value: function returnChildren(position) {
			var children = this.props.children;

			return Object(external_React_["isValidElement"])(children) ? children : children(position);
		}
	}, {
		key: 'render',
		value: function render() {
			return external_React_default.a.createElement(
				Contexts["d" /* StickyContext */].Consumer,
				null,
				this.renderChildren
			);
		}
	}]);

	return Sticky;
}(external_React_["Component"]);

Sticky_Sticky.propTypes = {
	children: PropTypes["b" /* stickyNodeType */],
	style: prop_types_default.a.object
};
/* harmony default export */ var components_Sticky = (Sticky_Sticky);
// CONCATENATED MODULE: ./src/components/StickySection.js
var StickySection_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var StickySection_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function StickySection_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function StickySection_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function StickySection_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function StickySection_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









var StickySection_StickySection = function (_Component) {
	StickySection_inherits(StickySection, _Component);

	function StickySection() {
		var _ref;

		var _temp, _this, _ret;

		StickySection_classCallCheck(this, StickySection);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = StickySection_possibleConstructorReturn(this, (_ref = StickySection.__proto__ || Object.getPrototypeOf(StickySection)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			stickyStyle: {},
			position: 'top',
			setStickyStyle: function setStickyStyle(stickyStyle) {
				_this.setState({ stickyStyle: stickyStyle });
			},
			stickyZIndex: 1
		}, _this.styles = StickySection_styles(), _this.handleTopEnter = function (entryState) {
			_this.setPosition(entryState.isTopBoundary ? 'fixed' : 'top');
		}, _this.handleTopLeave = function (entryState) {
			if (entryState.isOffsetTop) {
				_this.setPosition('fixed');
			}
		}, _this.handleIntersect = function (entryState) {
			if (entryState.isTopBoundary || entryState.isBottomVisible && !entryState.isTopVisible) {
				_this.setPosition('fixed');
			} else if (entryState.isTopVisible || entryState.isOffsetBottom) {
				_this.setPosition('top');
			} else if (entryState.isOffsetTop) {
				_this.setPosition('bottom');
			}
		}, _temp), StickySection_possibleConstructorReturn(_this, _ret);
	}

	StickySection_createClass(StickySection, [{
		key: 'setPosition',
		value: function setPosition(position) {
			if (this.state.position !== position) {
				this.setState({ position: position });
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _props = this.props,
			    children = _props.children,
			    sticky = _props.sticky,
			    stickyZIndex = _props.stickyZIndex,
			    style = _props.style,
			    debugId = _props.debugId,
			    other = StickySection_objectWithoutProperties(_props, ['children', 'sticky', 'stickyZIndex', 'style', 'debugId']),
			    stickyStyle = this.state.stickyStyle,
			    styles = this.styles;

			return external_React_default.a.createElement(
				Contexts["d" /* StickyContext */].Provider,
				{ value: this.state },
				external_React_default.a.createElement(
					'div',
					StickySection_extends({}, other, { style: styles.container(style) }),
					external_React_default.a.createElement('div', { style: stickyStyle }),
					external_React_default.a.createElement(components_Hook, {
						debugId: debugId + '(top)',
						onEnter: this.handleTopEnter,
						onLeave: this.handleTopLeave,
						style: styles.topHook
					}),
					children,
					sticky && external_React_default.a.createElement(
						components_Sticky,
						{ style: styles.sticky(stickyZIndex) },
						sticky
					),
					external_React_default.a.createElement(components_Hook, {
						debugId: debugId + '(bottom)',
						onIntersect: this.handleIntersect,
						style: styles.bottomHook(stickyStyle.height)
					})
				)
			);
		}
	}]);

	return StickySection;
}(external_React_["Component"]);

StickySection_StickySection.propTypes = {
	children: prop_types_default.a.node,
	sticky: PropTypes["b" /* stickyNodeType */],
	style: prop_types_default.a.object,
	stickyZIndex: prop_types_default.a.number,
	debugId: prop_types_default.a.string
};
/* harmony default export */ var components_StickySection = (StickySection_StickySection);
// CONCATENATED MODULE: ./src/constants.js
var PullThreshold = 80;
// CONCATENATED MODULE: ./src/components/RefreshControl.styles.js



/* harmony default export */ var RefreshControl_styles = (create({
	iconContainer: {
		width: 100,
		height: 32,
		position: 'absolute',
		left: '50%',
		bottom: PullThreshold / 2 - 16,
		marginLeft: -50,
		textAlign: 'center'
	},
	arrowIcon: function arrowIcon(isActive) {
		return {
			transform: 'rotateZ(' + (isActive ? 180 : 0) + 'deg)',
			transition: 'transform 0.3s'
		};
	}
}));
// CONCATENATED MODULE: ./src/components/Arrow.js
var Arrow_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Arrow_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }




function Arrow(_ref) {
	var color = _ref.color,
	    other = Arrow_objectWithoutProperties(_ref, ['color']);

	return external_React_default.a.createElement(
		'svg',
		Arrow_extends({
			xmlns: 'http://www.w3.org/2000/svg',
			viewBox: '0 0 40 40',
			width: '32px',
			height: '32px'
		}, other),
		external_React_default.a.createElement('line', {
			x1: '20',
			y1: '4',
			x2: '20',
			y2: '32',
			strokeLinecap: 'round',
			strokeWidth: 3,
			stroke: color
		}),
		external_React_default.a.createElement('polyline', {
			points: '10 24 20 34 30 24',
			strokeLinecap: 'round',
			strokeLinejoin: 'round',
			strokeWidth: 3,
			fill: 'none',
			stroke: color
		})
	);
}

Arrow.propTypes = {
	color: prop_types_default.a.string.isRequired
};
// CONCATENATED MODULE: ./src/components/Loading.js
var Loading_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Loading_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Loading_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Loading_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var Loading_style = { transition: 'opacity 0.3s' };

var Loading_Loading = function (_Component) {
	Loading_inherits(Loading, _Component);

	function Loading() {
		var _ref;

		var _temp, _this, _ret;

		Loading_classCallCheck(this, Loading);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = Loading_possibleConstructorReturn(this, (_ref = Loading.__proto__ || Object.getPrototypeOf(Loading)).call.apply(_ref, [this].concat(args))), _this), _this.highlighted = 0, _this.circles = [6, 20, 34], _temp), Loading_possibleConstructorReturn(_this, _ret);
	}

	Loading_createClass(Loading, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			var length = this.circles.length;

			this.intervalId = setInterval(function () {
				var next = _this2.highlighted + 1;
				_this2.highlighted = next >= length ? 0 : next;
				_this2.forceUpdate();
			}, 300);
		}
	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate() {
			return false;
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearInterval(this.intervalId);
		}
	}, {
		key: 'render',
		value: function render() {
			var color = this.props.color,
			    highlighted = this.highlighted,
			    circles = this.circles;

			return external_React_default.a.createElement(
				'svg',
				{
					xmlns: 'http://www.w3.org/2000/svg',
					viewBox: '0 0 40 40',
					width: '32px',
					height: '32px'
				},
				circles.map(function (cx, index) {
					return external_React_default.a.createElement('circle', {
						key: index,
						cx: cx,
						cy: '20',
						r: '3',
						fill: color,
						opacity: highlighted === index ? 1 : 0.2,
						style: Loading_style
					});
				})
			);
		}
	}]);

	return Loading;
}(external_React_["Component"]);

Loading_Loading.propTypes = {
	color: prop_types_default.a.string.isRequired
};
/* harmony default export */ var components_Loading = (Loading_Loading);
// CONCATENATED MODULE: ./src/components/RefreshControlObserver.styles.js
var RefreshControlObserver_styles_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




/* harmony default export */ var RefreshControlObserver_styles = (create({
	container: function container(style, isRefreshing) {
		return RefreshControlObserver_styles_extends({}, style, {
			height: 0,
			overflow: 'hidden',
			position: 'relative',
			minHeight: isRefreshing ? PullThreshold : 0
		});
	}
}));
// CONCATENATED MODULE: ./src/components/RefreshControlObserver.js
var RefreshControlObserver_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var RefreshControlObserver_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function RefreshControlObserver_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function RefreshControlObserver_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RefreshControlObserver_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function RefreshControlObserver_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var RefreshControlObserver_RefreshControlObserver = function (_Component) {
	RefreshControlObserver_inherits(RefreshControlObserver, _Component);

	function RefreshControlObserver() {
		var _ref;

		var _temp, _this, _ret;

		RefreshControlObserver_classCallCheck(this, RefreshControlObserver);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = RefreshControlObserver_possibleConstructorReturn(this, (_ref = RefreshControlObserver.__proto__ || Object.getPrototypeOf(RefreshControlObserver)).call.apply(_ref, [this].concat(args))), _this), _this.styles = RefreshControlObserver_styles(), _this.state = {
			isActive: false
		}, _this.domRef = function (dom) {
			_this.dom = dom;
		}, _this.renderChildren = function (refreshState) {
			if (!_this.refreshState) {
				_this.refreshState = refreshState;
				refreshState.mount(_this);
			}

			var _this2 = _this,
			    _this2$props = _this2.props,
			    children = _this2$props.children,
			    style = _this2$props.style,
			    isRefreshing = _this2$props.isRefreshing,
			    onRefresh = _this2$props.onRefresh,
			    other = RefreshControlObserver_objectWithoutProperties(_this2$props, ['children', 'style', 'isRefreshing', 'onRefresh']),
			    isActive = _this2.state.isActive,
			    styles = _this2.styles;

			return external_React_default.a.createElement(
				'div',
				RefreshControlObserver_extends({}, other, {
					style: styles.container(style, isRefreshing),
					ref: _this.domRef
				}),
				children({ isRefreshing: isRefreshing, isActive: isActive })
			);
		}, _temp), RefreshControlObserver_possibleConstructorReturn(_this, _ret);
	}

	RefreshControlObserver_createClass(RefreshControlObserver, [{
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			if (!prevProps.isRefreshing && this.props.isRefreshing) {
				this.enableTransition();
				this.setHeight(PullThreshold);
			} else if (prevProps.isRefreshing && !this.props.isRefreshing) {
				this.end();
				this.setHeight(0);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.refreshState.unmount();
		}
	}, {
		key: 'requestRefresh',
		value: function requestRefresh() {
			var onRefresh = this.props.onRefresh;

			onRefresh && onRefresh();
		}
	}, {
		key: 'setHeight',
		value: function setHeight(val) {
			var max = PullThreshold;
			var height = val > 0 ? val > max ? max + (val - max) / 2 : val : 0;
			var isActive = this.state.isActive,
			    dom = this.dom;

			dom.style.height = height + 'px';

			if (height >= max && !isActive) {
				this.setState({ isActive: true });
			} else if (height < max && isActive) {
				this.setState({ isActive: false });
			}
		}
	}, {
		key: 'enableTransition',
		value: function enableTransition() {
			this.dom.style.transition = 'height 0.3s ease-out, min-height 0.3s ease-out';
		}
	}, {
		key: 'disableTransition',
		value: function disableTransition() {
			this.dom.style.transition = 'none';
		}
	}, {
		key: 'end',
		value: function end() {
			if (this.state.isActive) {
				this.enableTransition();
				this.setState({ isActive: false });
			}
		}
	}, {
		key: 'attemptToRefresh',
		value: function attemptToRefresh() {
			var _props = this.props,
			    onRefresh = _props.onRefresh,
			    isRefreshing = _props.isRefreshing,
			    isActive = this.state.isActive;

			if (onRefresh && !isRefreshing && isActive) {
				onRefresh();
			}
			this.end();
			if (isRefreshing) {
				this.setHeight(PullThreshold);
			} else {
				this.setHeight(0);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			return external_React_default.a.createElement(
				Contexts["c" /* RefreshContext */].Consumer,
				null,
				this.renderChildren
			);
		}
	}]);

	return RefreshControlObserver;
}(external_React_["Component"]);

RefreshControlObserver_RefreshControlObserver.propTypes = {
	isRefreshing: prop_types_default.a.bool.isRequired,
	onRefresh: prop_types_default.a.func,
	style: prop_types_default.a.object,
	children: prop_types_default.a.func.isRequired
};
/* harmony default export */ var components_RefreshControlObserver = (RefreshControlObserver_RefreshControlObserver);
// CONCATENATED MODULE: ./src/components/RefreshControl.js
var RefreshControl_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var RefreshControl_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function RefreshControl_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function RefreshControl_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RefreshControl_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function RefreshControl_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var RefreshControl_RefreshControl = function (_Component) {
	RefreshControl_inherits(RefreshControl, _Component);

	function RefreshControl() {
		var _ref;

		var _temp, _this, _ret;

		RefreshControl_classCallCheck(this, RefreshControl);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = RefreshControl_possibleConstructorReturn(this, (_ref = RefreshControl.__proto__ || Object.getPrototypeOf(RefreshControl)).call.apply(_ref, [this].concat(args))), _this), _this.styles = RefreshControl_styles(), _this.saveRef = function (refreshControl) {
			_this.refreshControl = refreshControl;
		}, _temp), RefreshControl_possibleConstructorReturn(_this, _ret);
	}

	RefreshControl_createClass(RefreshControl, [{
		key: 'requestRefresh',
		value: function requestRefresh() {
			var refreshControl = this.refreshControl;

			refreshControl && refreshControl.requestRefresh();
		}
	}, {
		key: 'render',
		value: function render() {
			var _props = this.props,
			    color = _props.color,
			    other = RefreshControl_objectWithoutProperties(_props, ['color']),
			    styles = this.styles;

			return external_React_default.a.createElement(
				components_RefreshControlObserver,
				RefreshControl_extends({}, other, { ref: this.saveRef }),
				function (_ref2) {
					var isRefreshing = _ref2.isRefreshing,
					    isActive = _ref2.isActive;
					return external_React_default.a.createElement(
						'div',
						{ style: styles.iconContainer },
						isRefreshing ? external_React_default.a.createElement(components_Loading, { color: color }) : external_React_default.a.createElement(Arrow, { color: color, style: styles.arrowIcon(isActive) })
					);
				}
			);
		}
	}]);

	return RefreshControl;
}(external_React_["Component"]);

RefreshControl_RefreshControl.propTypes = {
	isRefreshing: prop_types_default.a.bool.isRequired,
	onRefresh: prop_types_default.a.func,
	color: prop_types_default.a.string,
	style: prop_types_default.a.object
};
RefreshControl_RefreshControl.defaultProps = {
	color: '#333'
};
/* harmony default export */ var components_RefreshControl = (RefreshControl_RefreshControl);
// CONCATENATED MODULE: ./src/index.js
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ScrollView", function() { return components_ScrollView; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ScrollObserver", function() { return ScrollObserver["a" /* default */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "StickySection", function() { return components_StickySection; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Fixed", function() { return components_Fixed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "RefreshControl", function() { return components_RefreshControl; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "RefreshControlObserver", function() { return components_RefreshControlObserver; });













/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(10);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (false) { var printWarning; }

module.exports = warning;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {// @flow


var key = '__global_unique_id__';

module.exports = function() {
  return global[key] = (global[key] || 0) + 1;
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _gud = __webpack_require__(13);

var _gud2 = _interopRequireDefault(_gud);

var _warning = __webpack_require__(11);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MAX_SIGNED_31_BIT_INT = 1073741823;

// Inlined Object.is polyfill.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + (0, _gud2.default)() + '__';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    function Provider() {
      var _temp, _this, _ret;

      _classCallCheck(this, Provider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
    }

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits = void 0;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0; // No change
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          if (false) {}

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    Provider.prototype.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(_react.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

  var Consumer = function (_Component2) {
    _inherits(Consumer, _Component2);

    function Consumer() {
      var _temp2, _this2, _ret2;

      _classCallCheck(this, Consumer);

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
        value: _this2.getValue()
      }, _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({ value: _this2.getValue() });
        }
      }, _temp2), _possibleConstructorReturn(_this2, _ret2);
    }

    Consumer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;

      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    Consumer.prototype.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;

      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    Consumer.prototype.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    Consumer.prototype.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(_react.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);


  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

exports.default = createReactContext;
module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(18);
var invariant = __webpack_require__(17);
var ReactPropTypesSecret = __webpack_require__(16);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ })
/******/ ]);
});
//# sourceMappingURL=react-scroll-view.js.map